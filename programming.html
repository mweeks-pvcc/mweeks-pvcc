<!DOCTYPE = html>
<!--NAME: (Matt Weeks)
    Prog Purpose : This is my programming HTML program: Programming html
-->
<html lang = "en">
    <head>
        <title>Hello World</title>
        </head>
        <body style ="color:#2e3883; background-color:#b3b9db; font-family:tahoma,verdana;">
            <h1>Chapter 5 Programming ALgorithms & Software Testing</h1>
            <h2> Phases of computer program development:</h2>
            <table>
            <tr>
            <td> Phase 1:</td>
            <td> Understand the problem</td>    
            </tr>
            <tr> 
            <td> Phase 2:</td>
            <td> Design an algorithm to solve the problem</td>
            </tr>
            <tr>
            <td> Phase 3:</td>
            <td> Write the program code in appropritate language based on the algorithm</td>
            </tr>
            <tr>
            <td> Phase 4:</td>
            <td> Enter th program and save</td>
            </tr>
            <tr>
            <td> Phase 5:</td>
            <td> Execute the program</td>
            </tr>
            <tr>
            <td> Phase 6:</td>
            <td> Test the program, find the errors and debug, then retest</td>
            </tr>
            <tr>
            <td> Phase 7:</td>
            <td> Document and evaluate the program</td>
            </tr>
            </table>
            <h2> Programming Structures:</h2>

  <ol>
    <li> Sequential structure: Top-down execution </li>
    <li> Decisive structures: if/then/else</li>
    <li> Iterative (Looping): while loop continuse looping until somthing is true repeat/until loop:comtinue looping until somthing is true for loop: loop a given number of times </li>
    <li> Recursive structures: Repeat a set of instructions as a subtask of itself</li>
    <li> Repition continues until : degenerative case, ehich is a termination condition, is met (degenerative case is also called a "base case")</li>
    </ol>
    <h2> Two classic programming/database probems</h2>
    <ol>
    <li> Sorting: Descending order/ Ascending order</li>
    <li> Sorting numbers</li>
    <li> Sorting strings (in accordance with ASCII values)
    <li> Searching: find specific data that meet a certain criteria</li>
    </ol>
    <ol>
    <h2> In database: </h2>
    <ol>
    <li> Filters: temporary search</li>
    <li> Queries: search criteria are saved so they don't have to be recreated</li>
    </ol>
    <h2> Two popular search techniques</h2>
    <ol>
    <li> Sequeintial search: search from the top to bottom ot bottom to top, one item at a timne</li>
    <li> Binary search: only works if data is sorted first, start in the middle, then go to half of that, etc</li>
    </ol>
    <h2> Two classic program goals:</h2>
    <ol>
    <li> Efficiciency: Program takes minimal time and/or resources</li>
    <li> Correctness: Program runs in expected ways ans works for all expected conditions </li>
    </ol>
    
    <h2> Software testing and verification</h2>
    <ol>
    <li> Accepting testing: Verifying whether the whole system works as intended. </li>
    <li> Integration testing:Ensuring that software components or functions operate together.</li>
    <li> Unit testing:Validating that each software unit performs as expected. A unit is the smallest testable component of an application.</li>
    <li> Functional testing:Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.</li>
    <li> Performance testing:Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.</li>
    <li> Regression testing:Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</li>
    <li> Stress testing:Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.</li>
    <li> Usability testing:Validating how well a customer can use a system or web application to complete a task.</li>
    </ol>
    <h2> Software testing is done to detect:</h2>
    <ol>
    <li> Architectural flaws</li>
    <li> Poor design decisions </li>
    <li> Invalid or incorrect functionality</li>
    <li> Security vulnerabilities</li>
    <li> Scalability issues</li>
    </ol>
    <h2>Testing best practicies:</h2>
    <ol> 
    <li>Continous testing: Development and operations collaborate from the beginning to the end</li>
    <li> Configuration management: test assests and track what software builds to test</li>
    <li> Servic virtulization: the ability to test virutally in order to save time and not waste resources and configuratiions can be easily altered without affecting the enviorment</li>
    <li> Defect or "bug tracking": tracking defects and determing how much of an impact they can cause</li>
    <li> Metrics and reporting: sharing status and test results, enable teams to see the overall heath of a project</li>
    <li> What is software testing? <a href="https://www.ibm.com/topics/software-testing"></a></li> 
    </ol>

          
           
        </body>
</html>  